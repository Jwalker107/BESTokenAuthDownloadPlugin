
"""Demonstrates a custom download-plugin for the BigFix Root Server.  This sample demonstrates performing downloads using a GitHub User Token to authenticate and download file(s)"""
#curl --header "Authorization: token github_pat_XXXXXXX" https://raw.githubusercontent.com/Jwalker107/AuthDownloadPlugin/main/README.md

import os
import sys
import json
import argparse
import keyring
import requests
import logging

def init_logging(logfile:str, level:int=20 ):
    # Creates the global 'logging' module and 'statuslog' variable - for debug and status logs
    # Creates the directories if they do not exist
    # Logs are created in the 'log' directory relative to the running script
  
    # FORMAT = "[%(filename)s:%(lineno)s - %(funcName)20s() ] %(message)s"
    logging.basicConfig(
        # level=logging.info,
        # Default log level is INFO but overridden by the config file after it is read
        level=level,
        format="[%(asctime)s] %(funcName)20s() [%(levelname)s] %(message)s",
        handlers=[logging.FileHandler(logfile), logging.StreamHandler()],
    )
    logging.info('Logging started to "%s"', logfile)



def download_file_stream(
    session=requests.Session(),
    url=None,
    output_file_path=None,
    chunk_size=8192,
    block_count=4,
):
    # Perform a streaming download to reduce memory footprint (otherwise the entire file download loads in RAM)
    if url is None or output_file_path is None:
        raise ValueError(f"url or output_file_path not defined")
    
    with session.get(url, stream=True, allow_redirects=True) as response:
        if not response.ok:
            raise ValueError(
                f"Download connection failed for {url} with HTTP {response.status_code}"
            )
        response.raise_for_status()
        with open(output_file_path, "wb") as f:
            chunk_number = 0
            for chunk in response.iter_content(chunk_size=chunk_size):
                f.write(chunk)
                # It's nice to show progress in the OS, by flushing to disk and syncing the filesystem so the file can be seen
                # to "grow", but it's also much slower.  So don't flush on every write, only flush at block_count interval
                chunk_number += 1
                if chunk_number % block_count == 0:
                    f.flush()
                    os.fsync(f.fileno())

def get_options(filepath):
    """Loads the options from the file specified in the --downloads argument"""
    # the --downloads <file> references a JSON configuration file generally stored in the TEMP directory, i.e.
    # c:\windows\temp\big97A8.tmp
    # 'id' is a message id specific for this action; a status message matching this id will be generated by the plugin
    # 'inbox' is the path in which status message to the server should be saved
    # 'downloads' is an array of download requests.  the 'file' is where the download plugin should save the download
    # Sample content:
    # {
    # "id":1702650720,
    # "inbox":"C:\\BES\\Server\\Mirror Server\\inbox",  # path in which to store a message file with results
    # "downloads":[
    #     {
    #      "id":57,
    #      "file":"C:\\BES\\Server\\wwwrootbes\\bfmirror\\downloads\\ActiveDownloads\\indexed_148295_1",
    #      "url":"TokenAuthDownload:\u002f\u002fraw.githubusercontent.com\u002fJwalker107\u002fAuthDownloadPlugin\u002fmain\u002fREADME.md",
    #      "sha1":{"algorithm":"sha1","value":"f919f61f325ff604e9359f8f448d3d1120cc81f2"},
    #      "size":79
    #     }
    #     ]
    # }
    with open(filepath, "r") as file:
        options = json.load(file)
    return options

def sendResults(results, options):
    """Create a message file detailing download results to the server"""
    # sample message: 
    #  {"message": "status", "id": 1702650720, "status": [{"id": 57, "success": true, "error": null}]}
    message = {}
    message["message"] = "status"
    message["id"] = options["id"]
    message["status"] = results
       
    # results file must be named `plugin_MESSAGEID` and must be stored in the Mirror Server/Inbox path (as specified in the original request options)
    results_file=os.path.join(options['inbox'], f"plugin_{options['id']}")
    logging.info(f'Saving results to file {results_file} : {str(message)}')
    with open(results_file, "w") as status_file:
        json.dump(message, status_file)

def get_args(argv=sys.argv[1:]):
    """Configure and read command-line parameters"""
    # when invoked by the root server, the '--downloads <download_message_file>' arguments will be passed
    parser = argparse.ArgumentParser()
    parser.add_argument("--downloads", "-d", type=str, required=True)
    args=parser.parse_args(argv)
    return args

def get_config(config_file):
    """Read configuration from config.json"""
    # config.json stores options such as the download plugin name, log file name & log level, and optionally may have a 'token' value to store
    with open(config_file, 'r') as json_file:
        
        config=json.load(json_file)
    return config

def set_config(config, config_file):
    """Write updated configuration to config.json"""
    # If the config file contained a 'token' value, we will re-write the file to remove that value after storing it in the keyring
    with open(config_file, 'w') as file:
        json.dump(config, file)

def process_download(download_request:dict, plugin_system_name:str, session:requests.Session):
    result = {}
    result["id"] = download_request["id"]
    logging.info(f"Processing download id {result['id']}")
    url = download_request.get("url").replace(f"{plugin_system_name}://", "https://")
    logging.info(f"Download URL: {url}")
    logging.info(f"Output file: {download_request.get('file')}")
    # download_file_stream will raise an exception on HTTP errors in addition to connection errors
    # so any response other than 'ok' will be caught by this exception handler
    try:
        download_file_stream(
            session=session,
            url=url,
            output_file_path=download_request.get("file"),
            chunk_size=65536
        )
        result["success"] = True
        result["error"] = None

    except Exception as e:
        logging.info(f"Download failed with {str(e)}")
        result["success"] = False
        result["error"] = str(e)
    return result

def main():
        # Get path to the script directory
        # If the application is run as a bundle, the PyInstaller bootloader
        # # extends the sys module by a flag frozen=True and sets the app
        # # path into variable _MEIPASS'.
        # print("Using frozen config")
    if getattr(sys, "frozen", False):
         scriptPath = os.path.dirname(os.path.abspath(sys.executable))
    else:
        scriptPath = os.path.dirname(os.path.abspath(__file__))
    config_file=os.path.join(scriptPath, 'config.json')
    config=get_config(config_file)
    log_file=os.path.join(scriptPath, config.get('log','logfile.txt'))
    init_logging(log_file, level=config.get('log_level', 20))
    plugin_system_name = config.get('plugin_name', "TokenAuthDownload")

    # If 'token' has a value in config.json, use keyring to encrypt the token and then remove it from the config file  
    if config.get('token', None) is not None:
        logging.info('Storing token to keyring')
        keyring.set_password(
            config.get('plugin_name', 'TokenAuthDownload'),
            "",
            config.get('token')
        )
        config['token']=None
        logging.info('Removing token from config file')
        set_config(config, config_file)
    
    # process command-line arguments to get the --downloads parameter - the path to a json file containing a list of downloads
    args=get_args()

    logging.info(f"Processing downloads from {args.downloads}")
    logging.info(f"Retrieving keyring credential for {plugin_system_name}")
    token_container=keyring.get_credential(plugin_system_name, "")
    if token_container is None:
        raise ValueError("No stored token was found, try adding 'token' to the config.json")
    token=token_container.password

    options = get_options(args.downloads)

    results = []
    logging.info("Creating requests.Session")
    session = requests.Session()
    session.headers.update({"User-Agent": "Wget/1.14 (linux-gnu)"})
    session.headers.update({"Authorization": f"token {token}"})

    # This is tuned for ease-of-use rather than performance.
    # Currently each download is performed sequentially, not in parallel
    for download in options.get("downloads", []):
        results.append(process_download(download, plugin_system_name, session))

    # Send download status results to the downloads_listing file, where it will be read by the Server to provide action status / error messages to the console
    logging.info(f"Results: {str(results)}")
    sendResults(results, options)
    logging.info("Plugin finished")

if __name__ == "__main__":
    main()
    sys.exit()

